[{"categories":["前端","vue"],"content":"第一次写Vue，想着用现成的接口写个前端样例，但是遇到了各种问题，网上并没有比较详细的解释，在此记录一下。 前期准备 目前使用的环境是Vite + Vue + axios的配置，这里并不是重点，只是介绍下前期的配置。 ","date":"2023-04-05","objectID":"http://blog.panic.ltd/posts/web_vue_cloudflare_req/:0:0","tags":["web","vue","axios","vite","cloudflare"],"title":"Vite Vue axios调用cloudflare代理api 403问题","uri":"http://blog.panic.ltd/posts/web_vue_cloudflare_req/"},{"categories":["前端","vue"],"content":"axios托管 先创建统一的axios托管，依照下面文章： vue3 + vite 进行axios请求封装及接口API的统一管理 - 掘金 在src目录下创建api文件夹，status.ts文件进行状态码管理： export const showMessage = (status:number|string) : string =\u003e { let message:string = \"\"; switch (status) { case 400: message = \"请求错误(400)\"; break; case 401: message = \"未授权，请重新登录(401)\"; break; case 403: message = \"拒绝访问(403)\"; break; case 404: message = \"请求出错(404)\"; break; case 408: message = \"请求超时(408)\"; break; case 500: message = \"服务器错误(500)\"; break; case 501: message = \"服务未实现(501)\"; break; case 502: message = \"网络错误(502)\"; break; case 503: message = \"服务不可用(503)\"; break; case 504: message = \"网络超时(504)\"; break; case 505: message = \"HTTP版本不受支持(505)\"; break; default: message = `连接出错(${status})!`; } return `${message}，请检查网络或联系管理员！`; }; axios.ts文件对request请求进行封装： import axios from 'axios'; import {showMessage} from \"./status\"; import { ElMessage } from 'element-plus' // 引入el 提示框，这个项目里用什么组件库这里引什么 // 设置接口超时时间 axios.defaults.timeout = 60000; axios.defaults.baseURL = 'https://api.lolicon.app' // 注意这里的写法是错误的，涉及到跨域和cloudflare绕过的问题，我们往后讲 //http request 拦截器 axios.interceptors.request.use( (config: { headers: { 'Content-Type': string; // 传参方式json }; }) =\u003e { // 配置请求头 config.headers = { 'Content-Type':'application/json', // 传参方式json }; return config; }, (error: any) =\u003e { return Promise.reject(error); } ); //http response 拦截器 axios.interceptors.response.use( (response: any) =\u003e { return response; }, (error: { response: any; }) =\u003e { const {response} = error; if (response) { // 请求已发出，但是不在2xx的范围 showMessage(response.status); // 传入响应码，匹配响应码对应信息 return Promise.reject(response.data); } else { console.log(error) ElMessage.warning('网络连接异常,请稍后再试!'); } } ); // 封装 GET POST 请求并导出 export function request(url='',params={},type='POST'){ //设置 url params type 的默认值 return new Promise((resolve,reject)=\u003e{ let promise if( type.toUpperCase()==='GET' ){ promise = axios({ url, params }) }else if( type.toUpperCase()=== 'POST' ){ promise = axios({ method:'POST', url, params, }) } //处理返回 promise.then((res: any)=\u003e{ resolve(res) }).catch((err: any)=\u003e{ reject(err) }) }) } 需要注意的是，axios.ts的axios.defaults.baseURL配置目前来看是错误的，当然配置可以设置成环境变量，环境变量的相关文档可以看这篇博客： vite中环境变量的使用与配置（非常详细） - 掘金 最后api.ts对我们需要的方法进行封装： import { request } from './axios' // 随机涩图接口封装 export class LoliconService { static async getImg({params}: { params: any }) { //return request('/api/setu/v1',params,'get') return request('/setu/v2',params,'POST') } } ","date":"2023-04-05","objectID":"http://blog.panic.ltd/posts/web_vue_cloudflare_req/:1:0","tags":["web","vue","axios","vite","cloudflare"],"title":"Vite Vue axios调用cloudflare代理api 403问题","uri":"http://blog.panic.ltd/posts/web_vue_cloudflare_req/"},{"categories":["前端","vue"],"content":"可能遇到的问题 在import axios时可能会有相关提示找不到，我们在src目录下创建shims-vue.d.ts文件进行声明： declare module 'axios' ","date":"2023-04-05","objectID":"http://blog.panic.ltd/posts/web_vue_cloudflare_req/:2:0","tags":["web","vue","axios","vite","cloudflare"],"title":"Vite Vue axios调用cloudflare代理api 403问题","uri":"http://blog.panic.ltd/posts/web_vue_cloudflare_req/"},{"categories":["前端","vue"],"content":"组件中调用 我们找个组件去调用: 这里使用的elment-ui的el-button，在实际使用时替换成自己的button \u003ctemplate\u003e \u003ch1\u003eMain\u003c/h1\u003e \u003cel-button type=\"info\" @click=\"req\"\u003e点击请求\u003c/el-button\u003e \u003c/template\u003e \u003cscript setup\u003e import {LoliconService} from \"@/api/api.ts\"; const req = () =\u003e { LoliconService.getImg({ r18: 0, num: 1 }).then(res =\u003e { console.log(res); }).catch(err =\u003e { console.log(err); }) } \u003c/script\u003e \u003cstyle scoped\u003e \u003c/style\u003e 跨域问题 首先第一个问题就是我们的跨域问题，解决办法为使用vite的代理进行请求。 修改axios.ts的axios.defaults.baseURL，我们随便设置一个path，用于待会儿的替换。 axios.defaults.baseURL = '/himgApi' // 跳转到proxy代理 在Vite官方文档详细的说明了怎么配置server相关配置的问题： Vite 在项目根目录的vite.config.ts，根据官方的说明我们进行配置： import {defineConfig} from 'vite' import vue from '@vitejs/plugin-vue' import path from \"path\" // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], resolve: { alias: { '@': path.resolve(__dirname, 'src') } }, server: { host:'127.0.0.1', proxy: { '/himgApi': { target: 'https://api.lolicon.app', changeOrigin: true, rewrite: (path) =\u003e path.replace(/^\\/himgApi/, ''), } } } }) 其中需要配置上的就是server字段下的内容，其余根据自己实际情况自行配置即可。 server: { proxy: { '/himgApi': { target: 'https://api.lolicon.app', changeOrigin: true, rewrite: (path) =\u003e path.replace(/^\\/himgApi/, '') } } } 这些请求的时候就不会报跨域相关错误了。 403问题 此时打开控制台发现还有403的错误，最开始我还是很疑惑，随即找了个自己的接口进行了测试，测试结果为正常的，所以问题可能不出在我身上。 查看对应请求的响应头的report-to带有cloudflare字段，显然是cloudflare搞得鬼，并且这时我们发现，我们在设置axios托管设置的\"Content-Type\"字段并没有出现请求标头上。 无意间找到着这篇文章： juejin.cn 找到了设置的办法，我们在vite.config.ts中进行以下配置： import {defineConfig} from 'vite' import vue from '@vitejs/plugin-vue' import path from \"path\" // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], resolve: { alias: { '@': path.resolve(__dirname, 'src') } }, server: { host:'127.0.0.1', proxy: { '/himgApi': { target: 'https://api.lolicon.app', changeOrigin: true, rewrite: (path) =\u003e path.replace(/^\\/himgApi/, ''), configure:(proxy) =\u003e { proxy.on('proxyReq',(proxyReq,req,res)=\u003e{ console.log(req) proxyReq.setHeader(\"Content-Type\",\"application/json\") proxyReq.removeHeader(\"Origin\") proxyReq.removeHeader(\"Referer\") }) } } } } }) 也就是添加以下配置，让我们可以对proxy的header进行配置： configure:(proxy) =\u003e { proxy.on('proxyReq',(proxyReq,req,res)=\u003e{ console.log(req) proxyReq.setHeader(\"Content-Type\",\"application/json\") proxyReq.removeHeader(\"Origin\") proxyReq.removeHeader(\"Referer\") }) } 其中Content-Type是我们需要添加的，而在刚才检查时Origin为http://127.0.0.1:5173，Referer为http://127.0.0.1:5173/home，对于正常来说没啥，但是可能会触发cloudflare的检测。（其实是我误打误撞测出来的） 配置好后我们再请求，这下就没啥问题了。 ","date":"2023-04-05","objectID":"http://blog.panic.ltd/posts/web_vue_cloudflare_req/:3:0","tags":["web","vue","axios","vite","cloudflare"],"title":"Vite Vue axios调用cloudflare代理api 403问题","uri":"http://blog.panic.ltd/posts/web_vue_cloudflare_req/"},{"categories":["golang","debug"],"content":"前提 在使用readline读取Nginx日志文件时发现个别日志解析时无法适配解析逻辑，按理来说Nginx日志是由服务自动生成的，不存在格式的问题。 打印Readline读取到的问题行的前后一行： // 问题行的上一行 2023-03-21T14:23:56+08:00 INFO formater/main.go:105 the previous line {\"line\": \"66.240.219.146 - - [05/Sep/2021:11:34:31 +0800] \\\"GET /images/favicon.ico?v=5.1.4 HTTP/1.1\\\" 200 16958 \\\"-\\\" \\\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:80.0) Gecko/20100101 Firefox/80.0\\\"\"} // 问题行 2023-03-21T14:23:56+08:00 INFO formater/main.go:106 the current line {\"line\": \"66.240.219.146 - - [05/Sep/2021:11:34:33 +0800] \\\"\\x03\\xC8:4a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0 0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\","date":"2023-03-21","objectID":"http://blog.panic.ltd/posts/golang_readline_stackoverflow/:1:0","tags":["golang","排错","debug"],"title":"Readline缓冲溢出导致断行","uri":"http://blog.panic.ltd/posts/golang_readline_stackoverflow/"},{"categories":["golang","debug"],"content":"原理 https://stackoverflow.com/questions/8757389/reading-a-file-line-by-line-in-go golang在使用Readline时截取4K大小的字符串，如果缓冲区满了就把剩下的作为下一串，并且不做任何拼接。 Readline(）源码： // ReadLine is a low-level line-reading primitive. Most callers should use // ReadBytes('\\n') or ReadString('\\n') instead or use a Scanner. // // ReadLine tries to return a single line, not including the end-of-line bytes. // If the line was too long for the buffer then isPrefix is set and the // beginning of the line is returned. The rest of the line will be returned // from future calls. isPrefix will be false when returning the last fragment // of the line. The returned buffer is only valid until the next call to // ReadLine. ReadLine either returns a non-nil line or it returns an error, // never both. // // The text returned from ReadLine does not include the line end (\"\\r\\n\" or \"\\n\"). // No indication or error is given if the input ends without a final line end. // Calling UnreadByte after ReadLine will always unread the last byte read // (possibly a character belonging to the line end) even if that byte is not // part of the line returned by ReadLine. func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) { line, err = b.ReadSlice('\\n') if err == ErrBufferFull { // Handle the case where \"\\r\\n\" straddles the buffer. if len(line) \u003e 0 \u0026\u0026 line[len(line)-1] == '\\r' { // Put the '\\r' back on buf and drop it from line. // Let the next call to ReadLine check for \"\\r\\n\". if b.r == 0 { // should be unreachable panic(\"bufio: tried to rewind past start of buffer\") } b.r-- line = line[:len(line)-1] } return line, true, nil } if len(line) == 0 { if err != nil { line = nil } return } err = nil if line[len(line)-1] == '\\n' { drop := 1 if len(line) \u003e 1 \u0026\u0026 line[len(line)-2] == '\\r' { drop = 2 } line = line[:len(line)-drop] } return } 可以看到Readline() 调用了ReadSlice()，查看源码： // ReadSlice reads until the first occurrence of delim in the input, // returning a slice pointing at the bytes in the buffer. // The bytes stop being valid at the next read. // If ReadSlice encounters an error before finding a delimiter, // it returns all the data in the buffer and the error itself (often io.EOF). // ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. // Because the data returned from ReadSlice will be overwritten // by the next I/O operation, most clients should use // ReadBytes or ReadString instead. // ReadSlice returns err != nil if and only if line does not end in delim. func (b *Reader) ReadSlice(delim byte) (line []byte, err error) { s := 0 // search start index for { // Search buffer. if i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i \u003e= 0 { i += s line = b.buf[b.r : b.r+i+1] b.r += i + 1 break } // Pending error? if b.err != nil { line = b.buf[b.r:b.w] b.r = b.w err = b.readErr() break } // Buffer full? if b.Buffered() \u003e= len(b.buf) { b.r = b.w line = b.buf err = ErrBufferFull break } s = b.w - b.r // do not rescan area we scanned before b.fill() // buffer is not full } // Handle last byte, if any. if i := len(line) - 1; i \u003e= 0 { b.lastByte = int(line[i]) b.lastRuneSize = -1 } return } 关键位置为： // Buffer full? if b.Buffered() \u003e= len(b.buf) { b.r = b.w line = b.buf err = ErrBufferFull break } 意思是： ReadSlice读取直到输入中第一次出现delim为止，并返回一个指向缓冲区中字节的切片 如果缓冲区满了并且不带delim，ReadSlice将失败，并显示错误ErrBufferFull 只有不以delim结尾时，ReadSlice才会返回err！= nil ","date":"2023-03-21","objectID":"http://blog.panic.ltd/posts/golang_readline_stackoverflow/:2:0","tags":["golang","排错","debug"],"title":"Readline缓冲溢出导致断行","uri":"http://blog.panic.ltd/posts/golang_readline_stackoverflow/"},{"categories":["golang","debug"],"content":"解决 直接换成ReadBytes(’\\n’) 或 ReadString(’\\n’) 对isPrefix返回值做校验 br := bufio.NewReader(fi) var buf []byte for { line, prefix, err := br.ReadLine() if err == io.EOF { break } // 追加到自定义缓冲区内 buf = append(buf, line...) // 如果prefix为真，则代表该行还有尚未读取完的数据，跳过后续具体操作，继续读取完该行剩余内容 if prefix { continue } str := string(buf) // 清空切片 buf = append(buf[:0], buf[len(buf):]...) } ","date":"2023-03-21","objectID":"http://blog.panic.ltd/posts/golang_readline_stackoverflow/:3:0","tags":["golang","排错","debug"],"title":"Readline缓冲溢出导致断行","uri":"http://blog.panic.ltd/posts/golang_readline_stackoverflow/"},{"categories":["golang","debug"],"content":"性能 https://zhuanlan.zhihu.com/p/32394492 根据对Readline和ReadBytes的性能对比，得到耗时如下： 读取10G文件耗时 readstring:30.717832767s readline:27.358268244s 读取20G文件耗时 readstring:59.937901346s readline:54.871384854s 读取30G文件耗时 readstring:1m21.657831495s readline:1m13.222376352s ","date":"2023-03-21","objectID":"http://blog.panic.ltd/posts/golang_readline_stackoverflow/:4:0","tags":["golang","排错","debug"],"title":"Readline缓冲溢出导致断行","uri":"http://blog.panic.ltd/posts/golang_readline_stackoverflow/"},{"categories":["服务配置","nginx"],"content":" https://www.nginx-cn.net/blog/using-free-ssltls-certificates-from-lets-encrypt-with-nginx/#auto-renewal ","date":"2023-03-17","objectID":"http://blog.panic.ltd/posts/nginx_let_encrypt/:0:0","tags":["web","nginx","ssl","服务配置"],"title":"Nginx配置免费的Let's Encrypt","uri":"http://blog.panic.ltd/posts/nginx_let_encrypt/"},{"categories":["服务配置","nginx"],"content":"1 下载 Let’s Encrypt 客户端 首先，下载 Let’s Encrypt 客户端 certbot。 如上所述，我们在 Ubuntu 16.04 上测试了相关指令，以下是在该平台上运行的相应命令： $ apt-get update $ sudo apt-get install certbot $ apt-get install python-certbot-nginx 用 Ubuntu 18.04和更高版本, 替代 Python 3版本: $ apt-get update $ sudo apt-get install certbot $ apt-get install python3-certbot-nginx ","date":"2023-03-17","objectID":"http://blog.panic.ltd/posts/nginx_let_encrypt/:1:0","tags":["web","nginx","ssl","服务配置"],"title":"Nginx配置免费的Let's Encrypt","uri":"http://blog.panic.ltd/posts/nginx_let_encrypt/"},{"categories":["服务配置","nginx"],"content":"2 设置 NGINX certbot 可以自动完成 NGINX 的 SSL/TLS 配置。它会在您的 NGINX 配置中查找并修改包含 [server_name](https://nginx.org/en/docs/http/ngx_http_core_module.html#server_name) 指令（含有您为其请求证书的域名）的 [server](https://nginx.org/en/docs/http/ngx_http_core_module.html#server) 块。在我们的示例中，域名为 www.example.com. 假设您在一个全新的 NGINX 安装上进行设置，请使用文本编辑器在 /etc/nginx/conf.d 目录中创建一个名为 *domain‑name*.conf 的文件（在我们的示例中为 www.example.com.conf）。 使用 server_name 指令指定您的域名（如果域名有变体的话也请指定）： server { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; server_name example.com www.example.com; } 保存文件，然后运行以下命令来验证配置的语法并重新启动 NGINX： $ nginx -t \u0026\u0026 nginx -s reload ","date":"2023-03-17","objectID":"http://blog.panic.ltd/posts/nginx_let_encrypt/:2:0","tags":["web","nginx","ssl","服务配置"],"title":"Nginx配置免费的Let's Encrypt","uri":"http://blog.panic.ltd/posts/nginx_let_encrypt/"},{"categories":["服务配置","nginx"],"content":"3 获取 SSL/TLS 证书 certbot 的 NGINX 插件负责重新配置 NGINX，并在必要时重新加载其配置。 运行以下命令，使用 NGINX 插件生成证书： $ sudo certbot --nginx -d example.com -d www.example.com 根据 certbot 的提示配置 HTTPS 设置，包括输入您的电子邮件地址并同意 Let’s Encrypt 服务条款。 证书生成后，NGINX 重新加载新设置。certbot 生成一条消息，显示证书成功生成，并指示证书在服务器上的位置。 Congratulations! You have successfully enabled https://example.com and https://www.example.com ------------------------------------------------------------------------------------- IMPORTANT NOTES: Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/example.com/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/example.com//privkey.pem Your cert will expire on 2017-12-12. **注：**Let’s Encrypt 证书在 90 天后到期（在本例中，到期时间为 2017 年 12 月 12 日）。有关自动更新证书的信息，请参阅下方“自动更新 Let’s Encrypt 证书”一节。 如果查看 *domain‑name*.conf，您会发现 certbot 已对其进行了修改： server { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; server_name example.com www.example.com; listen 443 ssl; # managed by Certbot # RSA certificate ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot # Redirect non-https traffic to https if ($scheme != \"https\") { return 301 https://$host$request_uri; } # managed by Certbot } ","date":"2023-03-17","objectID":"http://blog.panic.ltd/posts/nginx_let_encrypt/:3:0","tags":["web","nginx","ssl","服务配置"],"title":"Nginx配置免费的Let's Encrypt","uri":"http://blog.panic.ltd/posts/nginx_let_encrypt/"},{"categories":["服务配置","nginx"],"content":"4 自动更新 Let’s Encrypt 证书 Let’s Encrypt 证书将在 90 天后到期。我们建议您自动更新证书。此处，我们将一个 [cron](https://baike.baidu.com/item/cron) 作业添加到现有 crontab 文件中，以执行这一操作。 打开 crontab 文件。 $ crontab -e 添加 certbot 命令，并设置为每天运行。在本例中，我们每天中午运行该命令。该命令检查服务器上的证书是否会在未来 30 天内到期，如果是，则更新证书。--quiet 指令告知 certbot 不要生成输出。 0 12 * * * /usr/bin/certbot renew --quiet 保存并关闭文件。所有已安装的证书将自动更新和重新加载。 ","date":"2023-03-17","objectID":"http://blog.panic.ltd/posts/nginx_let_encrypt/:4:0","tags":["web","nginx","ssl","服务配置"],"title":"Nginx配置免费的Let's Encrypt","uri":"http://blog.panic.ltd/posts/nginx_let_encrypt/"},{"categories":["杂记","golang"],"content":"一直以来我也非常想要一个聊天式的机器人进行接入，在很多年前我的理想方案是微软小冰，可惜微软并没有提供公开的接口。chatgpt出现正好解决了我这一痛点，不过截止目前openai官方也并没有提供chatgpt的接口，但是通过openai的api接口我们可以模拟网页版的效果。 这个库其实在chatgpt出不久之后便封装好了，不过奈何感染了新冠，且感染的毒株有点过于生猛，让的我好多天下不了床… 我们将封装好的库接入qq机器人之后的效果： ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:0:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"如何注册账号 由于技术封锁的原因（猜测），openai并不对大陆的手机号进行注册上的支持，所以我们需要一些接码平台进行短信验证码的接收。可以参考一下教程： OpenAI 推出超神 ChatGPT 注册攻略来了 - V2EX 当然我们也可以google一些免费的接码平台，不过我猜羊毛应该薅的差不多了。 如果你发现因为代理地区的问题登录不了的话，请F12清除一下本地存储、会话存储以及Cookie。 然后获取到openai的api key。 ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:1:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"如何使用 ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:2:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"无上下文对话 代码很简单，如果你没有上下文（也就是对前后对话进行联系）的需求的话： package main import ( \"fmt\" \"github.com/solywsh/chatgpt\" \"time\" ) func main() { // The timeout is used to control the situation that the session is in a long and multi session situation. // If it is set to 0, there will be no timeout. Note that a single request still has a timeout setting of 30s. chat := chatgpt.New(\"openai_key\", \"user_id(not required)\", 30*time.Second) defer chat.Close() // //select { //case \u003c-chat.GetDoneChan(): // fmt.Println(\"time out/finish\") //} question := \"你认为2022年世界杯的冠军是谁？\" fmt.Printf(\"Q: %s\\n\", question) answer, err := chat.Chat(question) if err != nil { fmt.Println(err) } fmt.Printf(\"A: %s\\n\", answer) //Q: 你认为2022年世界杯的冠军是谁？ //A: 这个问题很难回答，因为2022年世界杯还没有开始，所以没有人知道冠军是谁。 } 我们在New的时候你可能已经注意到了，第三个参数传入了一个时间30*time.Second进去，这代表这个对话的或者是client最多可以对话的时间，在这时间内你对话无限次（不过因为字符限制不可能），当然你也可以选择传入0进去代表不失效。 对话失效之后，我们通过GetDoneChan()函数接收信号，用来通知系统此对话已经失效。该机制其实设计用于像是qq群这种多人会话情景，控制超时时间时使用。具体应用可以看我qq机器人的部分对话实现： revue/chatgpt.go at main · solywsh/revue (github.com) 其中我们在每对一个新的用户创建对话时，同时也创建了goroutine，用以专门接收结束信号，这个信号我们可以人为close，也可以timeout。 go func() { if v, ok := chatMap.Get(strconv.Itoa(cpf.UserId)); ok { select { case \u003c-v.ChatGPT.GetDoneChan(): cpf.SendMsg(GetCqCodeAt(strconv.Itoa(cpf.UserId), \"\") + \" 结束与你的对话\") chatMap.Remove(strconv.Itoa(cpf.UserId)) } } }() ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:2:1","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"有上下文对话 与无上下文实现同理，只需将Chat改为ChatWithContext即可： package main import ( \"fmt\" \"github.com/solywsh/chatgpt\" \"time\" ) func main() { chat := chatgpt.New(\"openai_key\", \"user_id(not required)\", 10*time.Second) defer chat.Close() //select { //case \u003c-chat.GetDoneChan(): // fmt.Println(\"time out\") //} question := \"现在你是一只猫，接下来你只能用\\\"喵喵喵\\\"回答.\" fmt.Printf(\"Q: %s\\n\", question) answer, err := chat.ChatWithContext(question) if err != nil { fmt.Println(err) } fmt.Printf(\"A: %s\\n\", answer) question = \"你是一只猫吗？\" fmt.Printf(\"Q: %s\\n\", question) answer, err = chat.ChatWithContext(question) if err != nil { fmt.Println(err) } fmt.Printf(\"A: %s\\n\", answer) // Q: 现在你是一只猫，接下来你只能用\"喵喵喵\"回答. // A: 喵喵喵！ // Q: 你是一只猫吗？ // A: 喵喵~! } ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:2:2","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"实现原理 截止目前，openai官方其实并没开放chatgpt的模型接口，我们使用的模型也并不是chatgpt使用的模型，只不过能达到差不多的效果。网上大多实现方案是对网页进行抓包，通过cookie模拟浏览器请求的方式，不过这种方法一点也不优雅，参考sudoskys/Openaibot项目之后我恍然大悟于是决定造轮子，不过我怀疑openai也是这么干的。 原理很简单，我们只需要每次在ai对话时，告诉它之前的对话就行了。 我们先定义好角色和对话前提： var ( DefaultAiRole = \"AI\" DefaultHumanRole = \"Human\" DefaultCharacter = []string{\"helpful\", \"creative\", \"clever\", \"friendly\", \"lovely\", \"talkative\"} DefaultBackground = \"The following is a conversation with AI assistant. The assistant is %s\" DefaultPreset = \"\\n%s: 你好，让我们开始愉快的谈话！\\n%s: 我是 AI assistant ，请问你有什么问题？\" ) 在每次创建对话时都拼接好： ctx := \u0026ChatContext{ aiRole: \u0026role{Name: DefaultAiRole}, humanRole: \u0026role{Name: DefaultHumanRole}, background: fmt.Sprintf(DefaultBackground, strings.Join(DefaultCharacter, \", \")+\".\"), maxSeqTimes: 10, preset: fmt.Sprintf(DefaultPreset, DefaultHumanRole, DefaultAiRole), old: []conversation{}, seqTimes: 0, restartSeq: \"\\n\" + DefaultHumanRole + \": \", startSeq: \"\\n\" + DefaultAiRole + \": \", maintainSeqTimes: false, } 最后在每次对话时将旧对话拼接即可: var promptTable []string promptTable = append(promptTable, c.ChatContext.background) promptTable = append(promptTable, c.ChatContext.preset) // 拼接旧对话作为前提 for _, v := range c.ChatContext.old { if v.Role == c.ChatContext.humanRole { promptTable = append(promptTable, \"\\n\"+v.Role.Name+\": \"+v.Prompt) } else { promptTable = append(promptTable, v.Role.Name+\": \"+v.Prompt) } } promptTable = append(promptTable, \"\\n\"+c.ChatContext.restartSeq+question) prompt := strings.Join(promptTable, \"\\n\") prompt += c.ChatContext.startSeq 不过需要注意的是，openai官方对接口字符进行了限制，最多只能4096字节。 ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:3:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"一些效果 ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:4:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":null,"content":"网站重新部署中 由于之前博客网站使用的hexo框架，时间一久各种问题频繁出现，上面也有很多最开始接触计算机时写的一些没营养的文章，于是准备重新部署一个博客网站，改用hugo框架。目前正则施工中… ","date":"2022-12-13","objectID":"http://blog.panic.ltd/posts/first/:1:0","tags":null,"title":"网站重新部署中","uri":"http://blog.panic.ltd/posts/first/"},{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by  Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveIt\r","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:0:0","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Features ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:0","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Plausible Analytics supported  Yandex Metrica supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:1","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Appearance and Layout  Desktop/Mobile responsive layout  Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:2","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 73 social links supported  Up to 24 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  utterances comment system supported by utterances  giscus comment system supported by giscus ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:3","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightGallery  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $\\KaTeX$  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Cookie consent banner supported by cookieconsent  Person shortcode … ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:4","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:2:0","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Special Thanks Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:3:0","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"}]