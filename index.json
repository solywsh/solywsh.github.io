[{"categories":["杂记","golang"],"content":"一直以来我也非常想要一个聊天式的机器人进行接入，在很多年前我的理想方案是微软小冰，可惜微软并没有提供公开的接口。chatgpt出现正好解决了我这一痛点，不过截止目前openai官方也并没有提供chatgpt的接口，但是通过openai的api接口我们可以模拟网页版的效果。 这个库其实在chatgpt出不久之后便封装好了，不过奈何感染了新冠，且感染的毒株有点过于生猛，让的我好多天下不了床… 我们将封装好的库接入qq机器人之后的效果： ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:0:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"如何注册账号 由于技术封锁的原因（猜测），openai并不对大陆的手机号进行注册上的支持，所以我们需要一些接码平台进行短信验证码的接收。可以参考一下教程： OpenAI 推出超神 ChatGPT 注册攻略来了 - V2EX 当然我们也可以google一些免费的接码平台，不过我猜羊毛应该薅的差不多了。 如果你发现因为代理地区的问题登录不了的话，请F12清除一下本地存储、会话存储以及Cookie。 然后获取到openai的api key。 ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:1:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"如何使用 ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:2:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"无上下文对话 代码很简单，如果你没有上下文（也就是对前后对话进行联系）的需求的话： package main import ( \"fmt\" \"github.com/solywsh/chatgpt\" \"time\" ) func main() { // The timeout is used to control the situation that the session is in a long and multi session situation. // If it is set to 0, there will be no timeout. Note that a single request still has a timeout setting of 30s. chat := chatgpt.New(\"openai_key\", \"user_id(not required)\", 30*time.Second) defer chat.Close() // //select { //case \u003c-chat.GetDoneChan(): // fmt.Println(\"time out/finish\") //} question := \"你认为2022年世界杯的冠军是谁？\" fmt.Printf(\"Q: %s\\n\", question) answer, err := chat.Chat(question) if err != nil { fmt.Println(err) } fmt.Printf(\"A: %s\\n\", answer) //Q: 你认为2022年世界杯的冠军是谁？ //A: 这个问题很难回答，因为2022年世界杯还没有开始，所以没有人知道冠军是谁。 } 我们在New的时候你可能已经注意到了，第三个参数传入了一个时间30*time.Second进去，这代表这个对话的或者是client最多可以对话的时间，在这时间内你对话无限次（不过因为字符限制不可能），当然你也可以选择传入0进去代表不失效。 对话失效之后，我们通过GetDoneChan()函数接收信号，用来通知系统此对话已经失效。该机制其实设计用于像是qq群这种多人会话情景，控制超时时间时使用。具体应用可以看我qq机器人的部分对话实现： revue/chatgpt.go at main · solywsh/revue (github.com) 其中我们在每对一个新的用户创建对话时，同时也创建了goroutine，用以专门接收结束信号，这个信号我们可以人为close，也可以timeout。 go func() { if v, ok := chatMap.Get(strconv.Itoa(cpf.UserId)); ok { select { case \u003c-v.ChatGPT.GetDoneChan(): cpf.SendMsg(GetCqCodeAt(strconv.Itoa(cpf.UserId), \"\") + \" 结束与你的对话\") chatMap.Remove(strconv.Itoa(cpf.UserId)) } } }() ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:2:1","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"有上下文对话 与无上下文实现同理，只需将Chat改为ChatWithContext即可： package main import ( \"fmt\" \"github.com/solywsh/chatgpt\" \"time\" ) func main() { chat := chatgpt.New(\"openai_key\", \"user_id(not required)\", 10*time.Second) defer chat.Close() //select { //case \u003c-chat.GetDoneChan(): // fmt.Println(\"time out\") //} question := \"现在你是一只猫，接下来你只能用\\\"喵喵喵\\\"回答.\" fmt.Printf(\"Q: %s\\n\", question) answer, err := chat.ChatWithContext(question) if err != nil { fmt.Println(err) } fmt.Printf(\"A: %s\\n\", answer) question = \"你是一只猫吗？\" fmt.Printf(\"Q: %s\\n\", question) answer, err = chat.ChatWithContext(question) if err != nil { fmt.Println(err) } fmt.Printf(\"A: %s\\n\", answer) // Q: 现在你是一只猫，接下来你只能用\"喵喵喵\"回答. // A: 喵喵喵！ // Q: 你是一只猫吗？ // A: 喵喵~! } ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:2:2","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"实现原理 截止目前，openai官方其实并没开放chatgpt的模型接口，我们使用的模型也并不是chatgpt使用的模型，只不过能达到差不多的效果。网上大多实现方案是对网页进行抓包，通过cookie模拟浏览器请求的方式，不过这种方法一点也不优雅，参考sudoskys/Openaibot项目之后我恍然大悟于是决定造轮子，不过我怀疑openai也是这么干的。 原理很简单，我们只需要每次在ai对话时，告诉它之前的对话就行了。 我们先定义好角色和对话前提： var ( DefaultAiRole = \"AI\" DefaultHumanRole = \"Human\" DefaultCharacter = []string{\"helpful\", \"creative\", \"clever\", \"friendly\", \"lovely\", \"talkative\"} DefaultBackground = \"The following is a conversation with AI assistant. The assistant is %s\" DefaultPreset = \"\\n%s: 你好，让我们开始愉快的谈话！\\n%s: 我是 AI assistant ，请问你有什么问题？\" ) 在每次创建对话时都拼接好： ctx := \u0026ChatContext{ aiRole: \u0026role{Name: DefaultAiRole}, humanRole: \u0026role{Name: DefaultHumanRole}, background: fmt.Sprintf(DefaultBackground, strings.Join(DefaultCharacter, \", \")+\".\"), maxSeqTimes: 10, preset: fmt.Sprintf(DefaultPreset, DefaultHumanRole, DefaultAiRole), old: []conversation{}, seqTimes: 0, restartSeq: \"\\n\" + DefaultHumanRole + \": \", startSeq: \"\\n\" + DefaultAiRole + \": \", maintainSeqTimes: false, } 最后在每次对话时将旧对话拼接即可: var promptTable []string promptTable = append(promptTable, c.ChatContext.background) promptTable = append(promptTable, c.ChatContext.preset) // 拼接旧对话作为前提 for _, v := range c.ChatContext.old { if v.Role == c.ChatContext.humanRole { promptTable = append(promptTable, \"\\n\"+v.Role.Name+\": \"+v.Prompt) } else { promptTable = append(promptTable, v.Role.Name+\": \"+v.Prompt) } } promptTable = append(promptTable, \"\\n\"+c.ChatContext.restartSeq+question) prompt := strings.Join(promptTable, \"\\n\") prompt += c.ChatContext.startSeq 不过需要注意的是，openai官方对接口字符进行了限制，最多只能4096字节。 ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:3:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":["杂记","golang"],"content":"一些效果 ","date":"2022-12-28","objectID":"http://blog.panic.ltd/posts/chatgpt/:4:0","tags":["chagtgpt","golang","package"],"title":"一个golang的chatgpt实现","uri":"http://blog.panic.ltd/posts/chatgpt/"},{"categories":null,"content":"网站重新部署中 由于之前博客网站使用的hexo框架，时间一久各种问题频繁出现，上面也有很多最开始接触计算机时写的一些没营养的文章，于是准备重新部署一个博客网站，改用hugo框架。目前正则施工中… ","date":"2022-12-13","objectID":"http://blog.panic.ltd/posts/first/:1:0","tags":null,"title":"网站重新部署中","uri":"http://blog.panic.ltd/posts/first/"},{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by  Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveIt\r","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:0:0","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Features ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:0","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Plausible Analytics supported  Yandex Metrica supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:1","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Appearance and Layout  Desktop/Mobile responsive layout  Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:2","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 73 social links supported  Up to 24 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  utterances comment system supported by utterances  giscus comment system supported by giscus ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:3","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightGallery  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $\\KaTeX$  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Cookie consent banner supported by cookieconsent  Person shortcode … ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:1:4","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:2:0","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"},{"categories":null,"content":"Special Thanks Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"http://blog.panic.ltd/about/:3:0","tags":null,"title":"About LoveIt","uri":"http://blog.panic.ltd/about/"}]